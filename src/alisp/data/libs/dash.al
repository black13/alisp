(defvar --doc-- "Dash helps you work with lists. This module is entirely based on the [dash.el](https://github.com/magnars/dash.el) library for emacs lisp. The functions in the module are implemented pureley in alisp.")

(defun d-map (fn list)
  "(d-map FN LIST)

Return a new list consisting of the result of applying `FN` to the items in `LIST`."
  (mapcar fn list))

(defun d-map-when (pred rep l)
  "(d-map-when PRED REP L)

Return a new list where the elements in `L` that do not match the `PRED` function are unchanged, and where the elements in `L` that do match the pred function are mapped through the `REP` function."
  (let ((res (list)))
    (dolist (el l)
      (when (pred el)
        (push res (rep el))))
    res))

(defun d-map-first (pred rep l)
  "(d-map-first PRED REP L)

Replace first item in `L` satisfying `PRED` with result of `REP` called on this item."
  (let ((res (list))
        (found nil))
    (dolist (el l)
      (if (and (pred el) (not found))
          (progn
            (push res (rep el))
            (setq found 't)))
      (push res el))
    res))

(defun d-map-last (pred rep l)
  "(d-map-last PRED REP L)

Replace last item in list satisfying pred with result of rep called on this item."
  (let ((res (list))
        (found nil))
    (dolist (el (reverse l))
      (if (and (pred el) (not found))
          (progn
            (push res (rep el))
            (setq found 't))
        (push res el)))
    (reverse res)))

(defun d-map-indexed (fn lis)
  "(d-map-indexed FN LIS)

Return a new list consisting of the result of (fn index item) for each item in list."
  (let ((res (list)))
    (dotimes (i (length lis))
      (push res (fn i (nth lis i))))
    res))

(defun d-annotate (fn lis)
  "(d-annotate FN LIS)

Return a list of cons cells where each cell is fn applied to each element of list paired with the unmodified element of list."
  (let ((res (list)))
    (dolist (el lis)
      (push res (list (fn el) el)))
    res))

(defun d-splice (pred fun lis)
  "(d-splice PRED FUN LIS)

Splice lists generated by fun in place of elements matching pred in list. `fun` takes the element matching pred as input."
  (let ((res (list)))
    (dolist (el lis)
      (if (pred el)
          (dolist (new-el (fun el))
            (push res new-el))
        (push res el)))
    res))

(defun d-splice-list (pred new-list lis)
  "(d-splice-list PRED NEW-LIST LIS)

Splice new-list in place of elements matching pred in list."
  (let ((res (list)))
    (dolist (el lis)
      (if (pred el)
          (dolist (new-el new-list)
            (push res new-el))
        (push res el)))
    res))

(defun d-mapcat (fn lis)
  "(d-mapcat FN LIS)

Return the concatenation of the result of mapping fn over list. Thus function fn should return a list."
  (let ((res (list)))
    (dolist (el lis)
      (dolist (new-el (fn el))
        (push res new-el)))
    res))

(defun d-copy (arg)
  "(d-copy ARG)

Create a shallow copy of list."
  (let ((res (list)))
    (dolist (el arg)
      (push res el))
    res))

(defun d-filter (pred lis)
  "(d-filter PRED LIS)

Return a new list of the items in list for which pred returns a non-nil value."
  (filter pred lis))

(defun d-remove (pred lis)
  "(d-remove PRED LIS)

Return a new list of the items in list for which pred returns nil."
  (filter (lambda (x) (not (pred x))) lis))

(defun d-remove-first (pred lis)
  "(d-remove-first PRED LIS)

Return a new list of the items in list for which pred returns nil."
  (let ((res (list))
        (found nil))
    (dolist (el lis)
      (if (and (pred el) (not found))
          (setq found 't)
        (push res el)))
    res))

(defun d-remove-last (pred lis)
  "(d-remove-last PRED LIS)

Return a new list with the last item matching pred removed."
  (let ((res (list))
        (found nil))
    (dolist (el (reverse lis))
      (if (and (pred el) (not found))
          (setq found 't)
        (push res el)))
    (reverse res)))

(defun d-remove-item (item list)
  "(d-remove-item ITEM LIST)

Remove all occurrences of item from list."
  (delete list item))

(defun d-non-nil (list)
  "(d-non-nil LIST)

Return all non-nil elements of list."
  (filter (lambda (x) (not ( equal x nil))) list))

(defun d-slice (lis from &optional to step)
  "(d-slice LIS FROM &OPTIONAL TO STEP)

Return copy of list, starting from index from to index to."
  (when (equal from to) (return (list)))
  (let ((res (list)))
    (dolist (i (range from (if to (if (> 0 to) (+ (length lis) to 1) to) (length lis)) (if step step 1)))
      (push res (nth lis i)))
    res))

(defun d-take (n lis)
  "(d-take N LIS)

Return a new list of the first n items in list, or all items if there are fewer than n."
  (let ((res (list)))
    (dolist (i (range 0 (min (length lis) n)))
      (push res (nth lis i)))
    res))

(defun d-take-last (n lis)
  "(d-take-last N LIS)

Return the last n items of list in order."
  (let ((res (list)))
    (dolist (i (range (max 0 (- (length lis) n)) (length lis)))
      (push res (nth lis i)))
    res))

(defun d-drop (n lis)
  "(d-drop N LIS)

Return the tail of list without the first n items."
  (let ((res (list)))
    (dolist (i (range n (length lis)))
      (push res (nth lis i)))
    res))

(defun d-drop-last (n lis)
  "(d-drop-last N LIS)

Remove the last n items of list and return a copy."
  (let ((res (list)))
    (dolist (i (range 0 (- (length lis) n)))
      (push res (nth lis i)))
    res))

(defun d-take-while (pred lis)
  "(d-take-while PRED LIS)

Return a new list of successive items from list while (pred item) returns a non-nil value."
  (let ((res (list)))
    (dolist (el lis)
      (if (pred el)
          (push res el)
        (return res)))
    res))

(defun d-drop-while (pred lis)
  "(d-drop-while PRED LIS)

Return the tail of list starting from the first item for which (pred item) returns nil."
  (let ((res (list))
        (found nil))
    (dolist (el lis)
      (unless (and (pred el) (not found))
        (push res el)
        (setq found 't)))
    res))

(defun d-select-by-indices (indices lis)
  "(d-select-by-indices INDICES LIS)

Return a list whose elements are elements from list selected as (nth i list) for all i from indices."
  (let ((res (list)))
    (dolist (i indices)
      (push res (nth lis i)))
    res))

(defun d-select-columns (columns table)
  "(d-select-columns COLUMNS TABLE)

Select columns from table.

table is a list of lists where each element represents one row. It is assumed each row has the same length."
  (let ((res (list)))
    (dolist (row table)
      (let ((new-row (list)))
        (when (not columns)  (push res 'nil) (continue))
        (dolist (i columns)
          (push new-row (nth row i)))
        (push res new-row)))
    res))

(defun d-select-column (column table)
  "(d-select-column COLUMN TABLE)

Select column from table.

table is a list of lists where each element represents one row. It is assumed each row has the same length.

The single selected column is returned as a list."
  (let ((res (list)))
    (dolist (row table)
      (when (equal column nil) (push res 'nil) (continue))
      (push res (nth row column)))
    res))

(defun d-keep (fn lis)
  "(d-keep FN LIS)

Return a new list of the non-nil results of applying fn to the items in list."
  (let ((res (list))
        el-res)
    (dolist (el lis)
      (setq el-res (fn el))
      (unless (equal el-res nil) (push res el-res)))
    res))

(defun d-concat (&rest lists)
  "(d-concat &REST LISTS)

Return a new list with the concatenation of the elements in the supplied lists."
  (let ((res (list)))
    (dolist (lis lists)
      (dolist (el lis)
        (push res el)))
    res))

(defun d-flatten (l)
  "(d-flatten L)

Take a nested list l and return its contents as a single, flat list."
  (let ((res (list)))
    (dolist (el l)
      (if (plist el)
          (dolist (new-el (d-flatten el)) (push res new-el))
        (push res el)))
    res))

(defun d-replace (old new lis)
  "(d-replace OLD NEW LIS)

Replace all old items in list with new.

Elements are compared using equal."
  (when (equal lis nil) (return nil))
  (let ((res (list)))
    (dolist (el lis)
      (if (equal el old)
          (push res new)
        (push res el)))
    res))

(defun d-replace-first (old new l)
  "(d-replace-first OLD NEW L)

Replace the first occurrence of old with new in list.

Elements are compared using equal."
  (when (equal l nil) (return nil))
  (let ((res (list))
        (found nil))
    (dolist (el l)
      (if (and (equal el old) (not found))
          (progn
            (push res new)
            (setq found 't))
        (push res el)))
    res))

(defun d-replace-last (old new l)
  "(d-replace-last OLD NEW L)

Replace the last occurrence of old with new in list.

Elements are compared using equal."
  (when (equal l nil) (return nil))
  (let ((res (list))
        (found nil))
    (dolist (el (reverse l))
      (if (and (equal el old) (not found))
          (progn
            (push res new)
            (setq found 't))
        (push res el)))
    (reverse res)))

(defun d-insert-at (n x lis)
  "(d-insert-at N X LIS)

Return a list with x inserted into list at position n."
  (let ((res (list)))
    (dolist (el lis)
      (push res el))
    (insert res (min n (length res)) x)))

(defun d-replace-at (n x lis)
  "(d-replace-at N X LIS)

Return a list with element at Nth position in list replaced with x."
  (let ((res (list)))
    (dotimes (i (length lis))
      (if (== i n)
          (push res x)
        (push res (nth lis i))))
    res))

(defun d-update-at (n func lis)
  "(d-update-at N FUNC LIS)

Return a list with element at Nth position in list replaced with (func (nth n list))."
  (let ((res (list)))
    (dotimes (i (length lis))
      (if (== i n)
          (push res (func (nth lis i)))
        (push res (nth lis i))))
    res))

(defun d-remove-at (n lis)
  "(d-remove-at N LIS)

Return a list with element at Nth position in list removed."
  (let ((res (list)))
    (dotimes (i (length lis))
      (unless (== i n)
        (push res (nth lis i))))
    res))

(defun d-remove-at-indices (indices lis)
  "(d-remove-at-indices INDICES LIS)

Return a list whose elements are elements from list without elements selected as (nth i list) for all i from indices."
  (let ((res (list)))
    (dotimes (i (length lis))
      (unless (contains indices i)
        (push res (nth lis i))))
    res))

(defun d-reduce-from (fn initial-value lis)
  "(d-reduce-from FN INITIAL-VALUE LIS)

Return the result of applying fn to initial-value and the first item in list, then applying fn to that result and the 2nd item, etc. If list contains no items, return initial-value and do not call fn."
  (let ((val (fn initial-value (head lis))))
    (dolist (el (tail lis))
      (setq val (fn val el)))
    val))

(defun d-reduce-r-from (fn initial-value lis)
  "(d-reduce-r-from FN INITIAL-VALUE LIS)

Replace conses with fn, nil with initial-value and evaluate the resulting expression. If list is empty, initial-value is returned and fn is not called."
  (let ((val (fn (last lis) initial-value)))
    (dolist (el (reverse (init lis)))
      (setq val (fn el val)))
    val))

(defun d-reduce (fn lis)
  "(d-reduce FN LIS)

Return the result of applying fn to the first 2 items in list, then applying fn to that result and the 3rd item, etc. If list contains no items, return the result of calling fn with no arguments. If list contains a single item, return that item and do not call fn."
  (let ((val (fn (nth lis 0) (nth lis 1))))
    (dolist (i (range 2 (length lis)))
      (setq val (fn val (nth lis i))))
    val))

(defun d-reduce-r (fn lis)
  "(d-reduce-r FN LIS)

Replace conses with fn and evaluate the resulting expression. The final nil is ignored. If list contains no items, return the result of calling fn with no arguments. If list contains a single item, return that item and do not call fn.

The first argument of fn is the new item, the second is the accumulated value."
  (let* ((len (length lis))
         (val (fn (nth lis (- len 1)) (nth lis (- len 2)) )))
    (dolist (i (range 3 (+ len 1)))
      (setq val (fn val (nth lis (- len i))  )))
    val))

(defun d-reductions-from (fn init lis)
  "(d-reductions-from FN INIT LIS)

Return a list of the intermediate values of the reduction."
  (let ((res (list init (fn init (head lis)))))
    (dolist (i (range 1 (length lis)))
      (push res (fn (last res) (nth lis i))))
    res))

(defun d-reductions-r-from (fn initial-value lis)
  "(d-reductions-r-from FN INITIAL-VALUE LIS)

Return a list of the intermediate values of the reduction."
  (let ((res (list initial-value (fn (last lis) initial-value))))
    (dolist (el (reverse (init lis)))
      (push res (fn el (last res))))
    (reverse res)))

(defun d-reductions (fn lis)
  "(d-reductions FN LIS)

Return a list of the intermediate values of the reduction."
  (let ((res (list (head lis) (fn (nth lis 0) (nth lis 1)))))
    (dolist (i (range 2 (length lis)))
      (push res (fn (last res) (nth lis i))))
    res))

(defun d-reductions-r (fn lis)
  "(d-reductions-r FN LIS)

Return a list of the intermediate values of the reduction."
  (let* ((len (length lis))
         (res (list (fn (nth lis (- len 1)) (nth lis (- len 2)) ))))
    (dolist (i (range 3 (+ len 1)))
      (push res (fn (last res) (nth lis (- len i))  )))
    (shove res (last lis))
    (reverse res)))

(defun d-count (pred lis)
  "(d-count PRED LIS)

Counts the number of items in list where (pred item) is non-nil."
  (let ((cnt 0))
    (dolist (el lis)
      (when (pred el) (setq cnt (+ cnt 1))))
    cnt))

(defun d-sum (lis)
  "(d-sum LIS)

Return the sum of list."
  (when (equal lis nil) (return 0))
  (let ((sm 0))
    (dolist (el lis)
      (setq sm (+ sm el)))
    sm))

(defun d-running-sum (lis)
  "(d-running-sum LIS)

Return a list with running sums of items in list."
  (when (equal lis nil) (return '(0)))
  (let ((sm (list 0)))
    (dolist (el lis)
      (push sm (+ (last sm) el)))
    (tail sm)))

(defun d-product (lis)
  "(d-product LIS)

Return the product of list."
  (when (equal lis nil) (return 1))
  (let ((sm 1))
    (dolist (el lis)
      (setq sm (* sm el)))
    sm))

(defun d-running-product (lis)
  "(d-running-product LIS)

Return a list with running products of items in list."
  (when (equal lis nil) (return '(1)))
  (let ((sm (list 1)))
    (dolist (el lis)
      (push sm (* (last sm) el)))
    (tail sm)))

(defun d-inits (lis)
  "(d-inits LIS)

Return all prefixes of list."
  (when (equal nil lis) (return '(nil)))
  (let ((res (list nil)))
    (dotimes (i (length lis))
      (let ((in (list)))
        (dotimes (j (+ 1 i)) (push in (nth lis j)) )
        (push res in)))
    res))

(defun d-tails (lis)
  "(d-tails LIS)

Return all suffixes of list"
  (when (equal nil lis) (return '(nil)))
  (let ((res (list nil))
        (rev (reverse lis)))
    (dotimes (i (length lis))
      (let ((in (list)))
        (dotimes (j (+ 1 i)) (push in (nth rev j)) )
        (push res (reverse in))))
    (reverse res)))

(defun d-common-prefix (&rest l)
  "(d-common-prefix &REST L)

Return the longest common prefix of lists."
  (when (== (length l) 1) (return (nth l 0)))
  (let ((res (list))
        (len (d-reduce min (mapcar length l))))
    (dotimes (i len)
      (let ((el (nth (nth l 0) i)))
        (dolist (lis l)
          (if (not (equal (nth lis i) el)) (return res)))
        (push res el)))
    res))

(defun d-common-suffix (&rest lists)
  "(d-common-suffix &REST LISTS)

Return the longest common suffix of lists."
  (reverse (apply 'd-common-prefix (mapcar quote (mapcar reverse lists)))))

(defun d-min (lis)
  "(d-min LIS)

Return the smallest value from list of numbers or markers."
  (apply min lis))

(defun d-min-by (comparator lis)
  "(d-min-by COMPARATOR LIS)

Take a comparison function comparator and a list and return the least element of the list by the comparison function."
  (d-reduce (lambda (acc x) (if (comparator x acc) acc x)) lis))

(defun d-max (lis)
  "(d-max LIS)

Return the largest value from list of numbers or markers."
  (apply max lis))

(defun d-max-by (comparator lis)
  "(d-max-by COMPARATOR LIS)

Take a comparison function comparator and a list and return the greatest element of the list by the comparison function."
  (d-reduce (lambda (acc x) (if (comparator x acc) x acc)) lis))

(defun d-iterate (fun init n)
  "(d-iterate FUN INIT N)

Return a list of iterated applications of fun to init."
  (let ((res (list))
        (last-el init))
    (dotimes (i n)
      (push res last-el)
      (setq last-el (fun last-el)))
    res))

(defun d-unfold (fun seed)
  "(d-unfold FUN SEED)

Build a list from seed using fun."
  (let ((res (list))
        (last-el (fun seed)))
    (while (not (equal last-el nil))
      (push res (nth last-el 0))
      (setq last-el (fun (nth last-el 1))))
    res))

(defun d-any? (pred lis)
  "(d-any? PRED LIS)

Return t if (pred x) is non-nil for any x in list, else nil."
  (any pred lis))

(defun d-all? (pred lis)
  "(d-all? PRED LIS)

Return t if (pred x) is non-nil for all x in list, else nil."
  (all pred lis))

(defun d-none? (pred list)
  "(d-none? PRED LIST)

Return t if (pred x) is nil for all x in list, else nil."
  (dolist (el list)
    (when (pred el)
      (return nil)))
  t)

(defun d-only-some? (pred lis)
  "(d-only-some? PRED LIS)

Return t if at least one item of list matches pred and at least one item of list does not match pred. Return nil both if all items match the predicate or if none of the items match the predicate."
  (let ((matched nil)
        (unmatched t)
        res)
    (dolist (el lis)
      (setq res (pred el))
      (setq matched (or res matched))
      (setq unmatched (and res unmatched)))
    (when (and matched (not unmatched)) (return t))))

(defun d-contains? (list element)
  "(d-contains? LIST ELEMENT)

Return non-nil if list contains element."
  (contains list element))

(defun d-same-items? (list1 list2)
  "(d-same-items? LIST1 LIST2)

Return true if list and list2 has the same items."
  (when (!= (length list1) (length list2)) (return nil))
  (dolist (el list1)
    (unless (contains list2 el) (return nil)))
  t)

(defun d-is-prefix? (prefix lis)
  "(d-is-prefix? PREFIX LIS)

Return non-nil if prefix is prefix of list."
  (when (> (length prefix) (length lis)) (return nil))
  (let ((i 0))
    (dolist (p prefix)
      (when (not (equal p (nth lis i))) (return nil))
      (1+ i))
    t))

(defun d-is-suffix? (suffix list)
  "(d-is-suffix? SUFFIX LIST)

Return non-nil if suffix is suffix of list."
  (d-is-prefix? (reverse suffix) (reverse list)))

(defun d-is-infix? (infix lis)
  "(d-is-infix? INFIX LIS)

Return non-nil if infix is infix of list."
  (let ((done nil)
        (ls (d-copy lis)))
    (while (and (not done) ls)
      (setq done (d-is-prefix? infix ls))
      (setq ls (tail ls)))
    done))

(defun d-split-at (n lis)
  "(d-split-at N LIS)

Return a list of ((-take n list) (-drop n list)), in no more than one pass through the list."
  (let ((res1 (list))
        (res2 (list)))
    (dotimes (i (min n (length lis))) (push res1 (nth lis i)))
    (dolist (i (range n (length lis))) (push res2 (nth lis i)))
    (list res1 res2)))

(defun d-split-with (pred lis)
  "(d-split-with PRED LIS)

Return a list of ((-take-while pred list) (-drop-while pred list)), in no more than one pass through the list."
  (let ((res1 (list))
        (res2 (list))
        (len (length lis))
        (i 0))
    (while (and (pred (nth lis i)) (< i len))
      (push res1 (nth lis i))
      (1+ i))
    (dolist (j (range i len)) (push res2 (nth lis j)))

    (list res1 res2)))

(defun d-split-on (item lis)
  "(d-split-on ITEM LIS)

Split the list each time item is found."
  (let ((res (list))
        (temp (list)))
    (dolist (el lis)
      (if (equal el item)
          (progn
            (push res (d-copy temp))
            (clear temp))
        (push temp el)))
    (push res (d-copy temp))
    res))

(defun d-split-when (fn lis)
  "(d-split-when FN LIS)

Split the list on each element where fn returns non-nil."
  (let ((res (list))
        (temp (list)))
    (dolist (el lis)
      (if (fn el)
          (progn
            (unless (empty temp)
              (push res (d-copy temp))
              (clear temp)))
        (push temp el)))
    (unless (empty temp) (push res (d-copy temp)))
    res))

(defun d-separate (pred lis)
  "(d-separate PRED LIS)

Return a list of ((-filter pred list) (-remove pred list)), in one pass through the list."
  (let ((res1 (list))
        (res2 (list)))
    (dolist (el lis)
      (if (pred el)
          (push res1 el)
        ( push res2 el)))
    (list res1 res2)))

(defun d-partition (n lis)
  "(d-partition N LIS)

Return a new list with the items in list grouped into n-sized sublists. If there are not enough items to make the last group n-sized, those items are discarded."
  (let ((res (list))
        (temp (list))
        (i 0))
    (dolist (el lis)
      (if (< i n)
          (progn
            (push temp el)
            (1+ i))
        (push res (d-copy temp))
        (clear temp)
        (push temp el)
        (setq i 1)))
    res))

(defun d-partition-all (n lis)
  "(d-partition-all N LIS)

Return a new list with the items in list grouped into n-sized sublists. The last group may contain less than n items."
  (let ((res (list))
        (temp (list))
        (i 0))
    (dolist (el lis)
      (if (< i n)
          (progn
            (push temp el)
            (1+ i))
        (push res (d-copy temp))
        (clear temp)
        (push temp el)
        (setq i 1)))
    (push res (d-copy temp))
    res))

(defun d--partition-all-in-steps-reversed (n step lis)
  (let ((res (list)))
    (while lis
      (push res (d-take n lis))
      (setq lis (d-drop step lis)))
    res))

(defun d-partition-in-steps (n step lis)
  "(d-partition-in-steps N STEP LIS)

Return a new list with the items in list grouped into n-sized sublists at offsets step apart. If there are not enough items to make the last group n-sized, those items are discarded."
  (filter (lambda (l) (== (length l) n))(d--partition-all-in-steps-reversed n step lis)))

(defun d-partition-all-in-steps (n step lis)
  "(d-partition-all-in-steps N STEP LIS)

Return a new list with the items in list grouped into n-sized sublists at offsets step apart. The last groups may contain less than n items."
  (d--partition-all-in-steps-reversed n step lis))

(defun d-partition-by (fn lis)
  "(d-partition-by FN LIS)

Apply fn to each item in list, splitting it each time fn returns a new value."
  (let ((res (list))
        (temp (list))
        prev-val val)
    (dolist (el lis)
      (setq val (fn el))
      (if (equal val prev-val)
          (push temp el)
        (push res (d-copy temp))
        (clear temp)
        (push temp el))
      (setq prev-val val))
    (unless (empty temp) (push res (d-copy temp)))
    res))

(defun d-partition-by-header (fn lis)
  "(d-partition-by-header FN LIS)

Apply fn to the first item in list. That is the header value. Apply fn to each item in list, splitting it each time fn returns the header value, but only after seeing at least one other value (the body)."
  (let ((res (list))
        (temp (list))
        (header (fn (head lis))))
    (dolist (el lis)
      (if (not (and (equal header (fn el))
                    (!= (length temp) 1)))
          (push temp el)
        (unless (empty temp) (push res (d-copy temp)))
        (clear temp)
        (push temp el)))
    (unless (empty temp) (push res (d-copy temp)))
    res))

(defun d-group-by (fn lis)
  "(d-group-by FN LIS)

Separate list into an alist whose keys are fn applied to the elements of list. Keys are compared by equal."
  (let ((res (list))
        (group-vals (list))
        (i 0)
        val)
    (dolist (el lis)
      (setq val (fn el))
      (if (contains group-vals val)
          (push (nth res (nth group-vals (inc (find group-vals val)))) el)
        (push group-vals val)
        (push group-vals i)
        (1+ i)
        (push res (list val el))))
    res))

(defun d-elem-index (elem list)
  "(d-elem-index ELEM LIST)

Return the index of the first element in the given list which is equal to the query element elem, or nil if there is no such element."
  (find list elem))

(defun d-elem-indices (elem lis)
  "(d-elem-indices ELEM LIS)

Return the indices of all elements in list equal to the query element elem, in ascending order."
  (let ((res (list)))
    (dolist (i (range 0 (length lis)))
      (when (equal (nth lis i) elem)
        (push res i)))
    res))

(defun d-find-index (pred lis)
  "(d-find-index PRED LIS)

Take a predicate pred and a list and return the index of the first element in the list satisfying the predicate, or nil if there is no such element."
  (dolist (i (range 0 (length lis)))
    (when (pred (nth lis i))
      (return i))))

(defun d-find-last-index (pred lis)
  "(d-find-last-index PRED LIS)

Take a predicate pred and a list and return the index of the last element in the list satisfying the predicate, or nil if there is no such element."
  (last (d-find-indices pred lis)))

(defun d-find-indices (pred lis)
  "(d-find-indices PRED LIS)

Return the indices of all elements in list satisfying the predicate pred, in ascending order."
  (let ((res (list)))
    (dolist (i (range 0 (length lis)))
      (when (pred (nth lis i))
        (push res i)))
    res))

(defun d-union (list1 list2)
  "(d-union LIST1 LIST2)

Return a new list containing the elements of list and elements of list2 that are not in list. The test for equality is done with equal, or with -compare-fn if that's non-nil."
  (let ((res (list)))
    (dolist (el list1) (unless (contain res el) (push res el)) )
    (dolist (el list2) (unless (contain res el) (push res el)) )
    res))

(defun d-difference (list list2)
  "(d-difference LIST LIST2)

Return a new list with only the members of list that are not in list2. The test for equality is done with equal, or with -compare-fn if that's non-nil."
  (let ((res (list)))
    (dolist (el list1) (unless (contain list2 el) (push res el)))
    res))

(defun d-intersection (list1 list2)
  "(d-intersection LIST1 LIST2)

Return a new list containing only the elements that are members of both list and list2. The test for equality is done with equal, or with -compare-fn if that's non-nil."
  (let ((res (list)))
    (dolist (el list1) (when (contain list2 el) (push res el)))
    res))

(defun d-powerset (lis)
  "(d-powerset LIS)

Return the power set of list."
  (when (<= (length lis) 1) (return (list lis (list))))
  (let ((res (list ))
        (h (head lis)))
    (dolist (el (d-powerset (tail lis)))
      (push res (d-concat `(,h) el))
      (push res el))
    res))

(defun d-permutations (lis)
  "(d-permutations LIS)

Return the permutations of list."
  (when (<= (length lis) 1) (return (list lis )))
  (let ((res (list ))
        (h (head lis)))
    (dolist (per (d-permutations (tail lis)))
      (dolist (i (range 0 (length lis)))
        (push res (d-concat (d-slice per 0 i) (list h) (d-slice per i)))))
    res))

(defun d-distinct (lis)
  "(d-distinct LIS)

Return a new list with all duplicates removed. The test for equality is done with equal, or with -compare-fn if that's non-nil."
  (let ((res (lis)))
    (dolist (el lis) (unless (contain res el) (push res el)))
    (length res)))

(defun d-repeat (n x)
  "(d-repeat N X)

Return a list with x repeated n times. Return nil if n is less than 1."
  (let ((res (list)))
    (dotimes (i n) (push res x))
    res))

(defun d-first (pred lis)
  "(d-first PRED LIS)

Return the first x in list where (pred x) is non-nil, else nil."
  (dolist (el lis)
    (when (pred el) (return el)))
  nil)

(defun d-some (pred list)
  "(d-some PRED LIST)

Return (pred x) for the first list item where (pred x) is non-nil, else nil."
  (dolist (el lis)
    (when (pred el) (return t)))
  nil)

(defun d-last (pred list)
  "(d-last PRED LIST)

Return the last x in list where (pred x) is non-nil, else nil."
  (dolist (el (reverse lis))
    (when (pred el) (return el)))
  nil)

(defun d-first-item (list)
  "(d-first-item LIST)

Return the first item of list, or nil on an empty list."
  (head list))

(defun d-second-item (arg1)
  "(d-second-item ARG1)

Return the second item of list, or nil if list is too short."
  (when (> (length arg1) 1) (return (nth arg1 1)))
  nil)

(defun d-third-item (arg1)
  "(d-third-item ARG1)

Return the third item of list, or nil if list is too short."
  (when (> (length arg1) 2) (return (nth arg1 2)))
  nil)

(defun d-fourth-item (arg1)
  "(d-fourth-item ARG1)

Return the fourth item of list, or nil if list is too short."
  (when (> (length arg1) 3) (return (nth arg1 3)))
  nil)

(defun d-fifth-item (arg1)
  "(d-fifth-item ARG1)

Return the fifth item of list, or nil if list is too short."
  (when (> (length arg1) 4) (return (nth arg1 4)))
  nil)

(defun d-last-item (list)
  "(d-last-item LIST)

Return the last item of list, or nil on an empty list."
  (last list))

(defun d-butlast (list)
  "(d-butlast LIST)

Return a list of all items in list except for the last."
  (init list))

(defun d-list (&rest args)
  "(d-list &REST ARGS)

Return a list with args."
  args)

(defun d-each (list fn)
  "(d-each LIST FN)

Call fn with every item in list. Return nil, used for side-effects only."
  (dolist (el list) (fn el)))

(defun d-each-while (list pred fn)
  "(d-each-while LIST PRED FN)

Call fn with every item in list while (pred item) is non-nil. Return nil, used for side-effects only."
  (dolist (el list)
    (when (pred el) (fn el))))

(defun d-each-indexed (list fn)
  "(d-each-indexed LIST FN)

Call (fn index item) for each item in list."
  (dolist (i (ranger 0 (length list)))
    (fn i (nth list i))))

(defun d-each-r (list fn)
  "(d-each-r LIST FN)

Call fn with every item in list in reversed order. Return nil, used for side-effects only."
  (dolist (el (reverse list)) (fn el)))

(defun d-each-r-while (list pred fn)
  "(d-each-r-while LIST PRED FN)

Call fn with every item in reversed list while (pred item) is non-nil. Return nil, used for side-effects only."
  (dolist (el (reverse list))
    (when (pred el) (fn el))))

(defun d-dotimes (num fn)
  "(d-dotimes NUM FN)

Repeatedly calls fn (presumably for side-effects) passing in integers from 0 through num-1."
  (dotimes (i num) (fn i)))
