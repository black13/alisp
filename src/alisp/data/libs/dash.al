(defun empty (lis)
  (== 0 (length lis)))

(defun nempty (lis)
  (!= 0 (length lis)))

(defun d-map (fn list)
  (mapcar fn list))

(defun d-map-when (pred rep l)
  (let ((res (list)))
    (dolist (el l)
      (when (pred el)
        (push res (rep el))))
    res))

(defun d-map-first (pred rep l)
  (let ((res (list))
        (found nil))
    (dolist (el l)
      (if (and (pred el) (not found))
          (progn
            (push res (rep el))
            (setq found 't)))
      (push res el))
    res))

(defun d-map-last (pred rep l)
  (let ((res (list))
        (found nil))
    (dolist (el (reverse l))
      (if (and (pred el) (not found))
          (progn
            (push res (rep el))
            (setq found 't))
        (push res el)))
    (reverse res)))

(defun d-map-indexed (fn lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (push res (fn i (nth lis i))))
    res))

(defun d-annotate (fn lis)
  (let ((res (list)))
    (dolist (el lis)
      (push res (list (fn el) el)))
    res))

(defun d-splice (pred fun lis)
  (let ((res (list)))
    (dolist (el lis)
      (if (pred el)
          (dolist (new-el (fun el))
            (push res new-el))
        (push res el)))
    res))

(defun d-splice-list (pred new-list lis)
  (let ((res (list)))
    (dolist (el lis)
      (if (pred el)
          (dolist (new-el new-list)
            (push res new-el))
        (push res el)))
    res))

(defun d-mapcat (fn lis)
  (let ((res (list)))
    (dolist (el lis)
      (dolist (new-el (fn el))
        (push res new-el)))
    res))

(defun d-copy (arg)
  (let ((res (list)))
    (dolist (el arg)
      (push res el))
    res))

(defun d-filter (pred lis)
  (filter pred lis))

(defun d-remove (pred lis)
  (filter (lambda (x) (not (pred x))) lis))

(defun d-remove-first (pred lis)
  (let ((res (list))
        (found nil))
    (dolist (el lis)
      (if (and (pred el) (not found))
          (setq found 't)
        (push res el)))
    res))

(defun d-remove-last (pred lis)
  (let ((res (list))
        (found nil))
    (dolist (el (reverse lis))
      (if (and (pred el) (not found))
          (setq found 't)
        (push res el)))
    (reverse res)))

(defun d-remove-item (item list)
  (delete list item))

(defun d-non-nil (list)
  (filter (lambda (x) (not ( equal x nil))) list))

(defun d-slice (lis from &optional to step)
  (let ((res (list)))
    (dolist (i (range from (if to (if (> 0 to) (+ (length lis) to 1) to) (length lis)) (if step step 1)))
      (push res (nth lis i)))    
    res))

(defun d-take (n lis)
  (let ((res (list)))
    (dolist (i (range 0 (min (length lis) n)))
      (push res (nth lis i)))
    res))

(defun d-take-last (n lis)
  (let ((res (list)))
    (dolist (i (range (max 0 (- (length lis) n)) (length lis)))
      (push res (nth lis i)))
    res))

(defun d-drop (n lis)
  (let ((res (list)))
    (dolist (i (range n (length lis)))
      (push res (nth lis i)))
    res))

(defun d-drop-last (n lis)
  (let ((res (list)))
    (dolist (i (range 0 (- (length lis) n)))
      (push res (nth lis i)))
    res))

(defun d-take-while (pred lis)
  (let ((res (list)))
    (dolist (el lis)
      (if (pred el)
          (push res el)
        (return res)))
    res))

(defun d-drop-while (pred lis)
  (let ((res (list))
        (found nil))
    (dolist (el lis)
      (unless (and (pred el) (not found))
        (push res el)
        (setq found 't)))
    res))

(defun d-select-by-indices (indices lis)
  (let ((res (list)))
    (dolist (i indices)
      (push res (nth lis i)))
    res))

(defun d-select-columns (columns table)
  (let ((res (list)))
    (dolist (row table)
      (let ((new-row (list)))
        (when (not columns)  (push res 'nil) (continue))
        (dolist (i columns)
          (push new-row (nth row i)))        
        (push res new-row)))
    res))

(defun d-select-column (column table)
  (let ((res (list)))
    (dolist (row table)
      (when (equal column nil) (push res 'nil) (continue))
      (push res (nth row column)))
    res))

(defun d-keep (fn lis)
  (let ((res (list))
        el-res)
    (dolist (el lis)
      (setq el-res (fn el))
      (unless (equal el-res nil) (push res el-res)))
    res))

(defun d-concat (&rest lists)
  (let ((res (list)))
    (dolist (lis lists)
      (dolist (el lis)
        (push res el)))
    res))

(defun d-flatten (l)
  (let ((res (list)))
    (dolist (el l)
      (if (plist el)
          (dolist (new-el (d-flatten el)) (push res new-el))
        (push res el)))
    res))

(defun d-replace (old new lis)
  (when (equal lis nil) (return nil))
  (let ((res (list)))
    (dolist (el lis)
      (if (equal el old)
          (push res new)
        (push res el)))
    res))

(defun d-replace-first (old new l)
  (when (equal l nil) (return nil))
  (let ((res (list))
        (found nil))
    (dolist (el l)
      (if (and (equal el old) (not found))
          (progn
            (push res new)
            (setq found 't))
        (push res el)))
    res))

(defun d-replace-last (old new l)
  (when (equal l nil) (return nil))
  (let ((res (list))
        (found nil))
    (dolist (el (reverse l))
      (if (and (equal el old) (not found))
          (progn
            (push res new)
            (setq found 't))
        (push res el)))
    (reverse res)))

(defun d-insert-at (n x lis)
  (let ((res (list)))
    (dolist (el lis)
      (push res el))
    (insert res (min n (length res)) x)))

(defun d-replace-at (n x lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (if (== i n)
          (push res x)
        (push res (nth lis i))))
    res))

(defun d-update-at (n func lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (if (== i n)
          (push res (func (nth lis i)))
        (push res (nth lis i))))
    res))

(defun d-remove-at (n lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (unless (== i n)
        (push res (nth lis i))))
    res))

(defun d-remove-at-indices (indices lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (unless (contains indices i)
        (push res (nth lis i))))
    res))



(defun d-reduce-from (fn initial-value lis)
  (let ((val (fn initial-value (head lis))))
    (dolist (el (tail lis))
      (setq val (fn val el)))
    val))

(defun d-reduce-r-from (fn initial-value lis)
  (let ((val (fn (last lis) initial-value)))
    (dolist (el (reverse (init lis)))
      (setq val (fn el val)))
    val))

(defun d-reduce (fn lis)
  (let ((val (fn (nth lis 0) (nth lis 1))))
    (dolist (i (range 2 (length lis)))
      (setq val (fn val (nth lis i))))
    val))

(defun d-reduce-r (fn lis)
  (let* ((len (length lis))
         (val (fn (nth lis (- len 1)) (nth lis (- len 2)) )))
    (dolist (i (range 3 (+ len 1)))
      (setq val (fn val (nth lis (- len i))  )))
    val))

(defun d-reductions-from (fn init lis)
  (let ((res (list init (fn init (head lis)))))
    (dolist (i (range 1 (length lis)))
      (push res (fn (last res) (nth lis i))))
    res))

(defun d-reductions-r-from (fn initial-value lis)
  (let ((res (list initial-value (fn (last lis) initial-value))))
    (dolist (el (reverse (init lis)))
      (push res (fn el (last res))))
    (reverse res)))

(defun d-reductions (fn lis)
  (let ((res (list (head lis) (fn (nth lis 0) (nth lis 1)))))
    (dolist (i (range 2 (length lis)))
      (push res (fn (last res) (nth lis i))))
    res))

(defun d-reductions-r (fn lis)
  (let* ((len (length lis))
         (res (list (fn (nth lis (- len 1)) (nth lis (- len 2)) ))))
    (dolist (i (range 3 (+ len 1)))
      (push res (fn (last res) (nth lis (- len i))  )))
    (shove res (last lis))
    (reverse res)))

(defun d-count (pred lis)
  (let ((cnt 0))
    (dolist (el lis)
      (when (pred el) (setq cnt (+ cnt 1))))
    cnt))

(defun d-sum (lis)
  (when (equal lis nil) (return 0))
  (let ((sm 0))
    (dolist (el lis)
      (setq sm (+ sm el)))
    sm))

(defun d-running-sum (lis)
  (when (equal lis nil) (return '(0)))
  (let ((sm (list 0)))
    (dolist (el lis)
      (push sm (+ (last sm) el)))
    (tail sm)))

(defun d-product (lis)
  (when (equal lis nil) (return 1))
  (let ((sm 1))
    (dolist (el lis)
      (setq sm (* sm el)))
    sm))

(defun d-running-product (lis)
  (when (equal lis nil) (return '(1)))
  (let ((sm (list 1)))
    (dolist (el lis)
      (push sm (* (last sm) el)))
    (tail sm)))

(defun d-inits (lis)
  (when (equal nil lis) (return '(nil)))
  (let ((res (list nil)))
    (dotimes (i (length lis))
      (let ((in (list)))
        (dotimes (j (+ 1 i)) (push in (nth lis j)) )
        (push res in)))
    res))

(defun d-tails (lis)
  (when (equal nil lis) (return '(nil)))
  (let ((res (list nil))
        (rev (reverse lis)))
    (dotimes (i (length lis))
      (let ((in (list)))
        (dotimes (j (+ 1 i)) (push in (nth rev j)) )
        (push res (reverse in))))
    (reverse res)))

(defun d-common-prefix (&rest l)
  (when (== (length l) 1) (return (nth l 0)))
  (let ((res (list))
        (len (d-reduce min (mapcar length l))))
    (dotimes (i len)
      (let ((el (nth (nth l 0) i)))
        (dolist (lis l)
          (if (not (equal (nth lis i) el)) (return res)))
        (push res el)))
    res))

(defun d-common-suffix (&rest lists)
  (reverse (apply 'd-common-prefix (mapcar quote (mapcar reverse lists)))))

(defun d-min (lis)
  (apply min lis))

(defun d-min-by (comparator lis)
  (d-reduce (lambda (acc x) (if (comparator x acc) acc x)) lis))

(defun d-max (lis)
  (apply max lis))

(defun d-max-by (comparator lis)
  (d-reduce (lambda (acc x) (if (comparator x acc) x acc)) lis))

(defun d-iterate (fun init n)
  (let ((res (list))
        (last-el init))
    (dotimes (i n)
      (push res last-el)
      (setq last-el (fun last-el)))
    res))

(defun d-unfold (fun seed)
  (let ((res (list))
        (last-el (fun seed)))
    (while (not (equal last-el nil))
      (push res (nth last-el 0))
      (setq last-el (fun (nth last-el 1))))
    res))

(defun d-any? (pred lis)
  (any pred lis))

(defun d-all? (pred lis)
  (all pred lis))

(defun d-none? (pred list)
  (dolist (el list)
    (when (pred el)
      (return nil)))
  t)

(defun d-only-some? (pred lis)
  (let ((matched nil)
        (unmatched t)
        res)
    (dolist (el lis)
      (setq res (pred el))
      (setq matched (or res matched))
      (setq unmatched (and res unmatched)))
    (when (and matched (not unmatched)) (return t))))

(defun d-contains? (list element)
  (contains list element))

(defun d-same-items? (list1 list2)
  (when (!= (length list1) (length list2)) (return nil))
  (dolist (el list1)
    (unless (contains list2 el) (return nil)))
  t)

(defun d-is-prefix? (prefix lis)
  (when (> (length prefix) (length lis)) (return nil))
  (let ((i 0))
    (dolist (p prefix)
      (when (not (equal p (nth lis i))) (return nil))
      (1+ i))
    t))

(defun d-is-suffix? (suffix list)
  (d-is-prefix? (reverse suffix) (reverse list)))

(defun d-is-infix? (infix lis)
  (let ((done nil)
        (ls (d-copy lis)))
    (while (and (not done) ls)
      (setq done (d-is-prefix? infix ls))
      (setq ls (tail ls)))
    done))

(defun d-split-at (n lis)
  (let ((res1 (list))
        (res2 (list)))
    (dotimes (i (min n (length lis))) (push res1 (nth lis i)))
    (dolist (i (range n (length lis))) (push res2 (nth lis i)))
    (list res1 res2)))

;; (dump (d-split-at 3 '(1 2 3 4 5))) ;; => '((1 2 3) (4 5))
;; (dump (d-split-at 17 '(1 2 3 4 5))) ;; => '((1 2 3 4 5) nil)

(defun d-split-with (pred lis)
  (let ((res1 (list))
        (res2 (list))
        (len (length lis))
        (i 0))
    (while (and (pred (nth lis i)) (< i len))
      (push res1 (nth lis i))
      (1+ i))
    (dolist (j (range i len)) (push res2 (nth lis j)))

    (list res1 res2)))

;; (dump (d-split-with 'even? '(1 2 3 4))) ;; => '(nil (1 2 3 4))
;; (dump (d-split-with 'even? '(2 4 5 6))) ;; => '((2 4) (5 6))

(defun d-split-on (item lis)
  (let ((res (list))
        (temp (list)))
    (dolist (el lis)
      (if (equal el item)
          (progn
            (push res (d-copy temp))
            (clear temp))
        (push temp el)))
    (push res (d-copy temp))
    res))

;; (dump (d-split-on '| '(Nil | Leaf a | Node Tree a))) ;; => '((Nil) (Leaf a) (Node [Tree a]))
;; (dump (d-split-on ':endgroup '("a" "b" :endgroup "c" :endgroup "d" "e"))) ;; => '(("a" "b") ("c") ("d" "e"))

(defun d-split-when (fn lis)
  (let ((res (list))
        (temp (list)))
    (dolist (el lis)
      (if (fn el)
          (progn
            (unless (empty temp)
              (push res (d-copy temp))
              (clear temp)))
        (push temp el)))
    (unless (empty temp) (push res (d-copy temp)))
    res))

;; (dump (d-split-when 'even? '(1 2 3 4 5 6))) ;; => '((1) (3) (5))
;; (dump (d-split-when 'even? '(1 2 3 4 6 8 9))) ;; => '((1) (3) (9))

(defun d-separate (pred lis)
  (let ((res1 (list))
        (res2 (list)))
    (dolist (el lis)
      (if (pred el)
          (push res1 el)
        ( push res2 el)))
    (list res1 res2)))

;; (dump (d-separate (lambda (num) (== 0 (mod num 2))) '(1 2 3 4 5 6 7))) ;; => '((2 4 6) (1 3 5 7))

(defun d-partition (n lis)
  (let ((res (list))
        (temp (list))
        (i 0))    
    (dolist (el lis)
      (if (< i n)
          (progn
            (push temp el)
            (1+ i))
        (push res (d-copy temp))
        (clear temp)
        (push temp el)
        (setq i 1)))
    res))

;; (dump (d-partition 2 '(1 2 3 4 5 6))) ;; => '((1 2) (3 4) (5 6))
;; (dump (d-partition 2 '(1 2 3 4 5 6 7)))
;; (dump (d-partition 3 '(1 2 3 4 5 6 7))) ;; => '((1 2 3) (4 5 6))

(defun d-partition-all (n lis)
  (let ((res (list))
        (temp (list))
        (i 0))    
    (dolist (el lis)
      (if (< i n)
          (progn
            (push temp el)
            (1+ i))
        (push res (d-copy temp))
        (clear temp)
        (push temp el)
        (setq i 1)))    
    (push res (d-copy temp))
    res))


;; (dump (d-partition-all 2 '(1 2 3 4 5 6))) ;; => '((1 2) (3 4) (5 6))
;; (dump (d-partition-all 2 '(1 2 3 4 5 6 7)))
;; (dump (d-partition-all 3 '(1 2 3 4 5 6 7))) ;; => '((1 2 3) (4 5 6))

(defun d--partition-all-in-steps-reversed (n step lis)
  (let ((res (list)))
    (while lis
      (push res (d-take n lis))
      (setq lis (d-drop step lis)))
    res))


(defun d-partition-in-steps (n step lis)
  (filter (lambda (l) (== (length l) n))(d--partition-all-in-steps-reversed n step lis)))

;; (dump (d-partition-in-steps 2 1 '(1 2 3 4))) ;; => '((1 2) (2 3) (3 4))
;; (dump (d-partition-in-steps 3 2 '(1 2 3 4))) ;; => '((1 2 3))
;; (dump (d-partition-in-steps 3 2 '(1 2 3 4 5))) ;; => '((1 2 3) (3 4 5))

(defun d-partition-all-in-steps (n step lis)
  (d--partition-all-in-steps-reversed n step lis))

;; (dump (d-partition-all-in-steps 2 1 '(1 2 3 4))) ;; => '((1 2) (2 3) (3 4) (4))
;; (dump (d-partition-all-in-steps 3 2 '(1 2 3 4))) ;; => '((1 2 3) (3 4))
;; (dump (d-partition-all-in-steps 3 2 '(1 2 3 4 5))) ;; => '((1 2 3) (3 4 5) (5))


(defun d-partition-by (fn lis)
  (let ((res (list))
        (temp (list))
        prev-val val)
    (dolist (el lis)
      (setq val (fn el))
      (if (equal val prev-val)
          (push temp el)
        (push res (d-copy temp))
        (clear temp)
        (push temp el))
      (setq prev-val val))
    (unless (empty temp) (push res (d-copy temp)))q
    res))

;; (dump (d-partition-by 'even? '())) ;; => '()
;; (dump (d-partition-by 'even? '(1 1 2 2 2 3 4 6 8))) ;; => '((1 1) (2 2 2) (3) (4 6 8))

(defun d-partition-by-header (fn lis)
  (let ((res (list))
        (temp (list))
        (header (fn (head lis))))
    (dolist (el lis)
      (if (not (and (equal header (fn el))
                    (!= (length temp) 1)))
          (push temp el)
        (unless (empty temp) (push res (d-copy temp)))
        (clear temp)
        (push temp el)))
    (unless (empty temp) (push res (d-copy temp)))
    res))

;; (dump (d-partition-by-header 'even? '(2 1 1 1 4 1 3 5 6 6 1))) ;; => '((2 1 1 1) (4 1 3 5) (6 6 1))

(defun d-group-by (fn lis)
  (let ((res (list))
        (group-vals (list))
        (i 0)
        val)
    (dolist (el lis)
      (setq val (fn el))
      (if (contains group-vals val)
          (progn
            (push (nth res (nth group-vals (inc (find group-vals val)))) el)
            )
        (push group-vals val)
        (push group-vals i)
        (1+ i)
        (push res (list val el))))    
    res))

(dump (d-group-by 'even? '(1 1 2 2 2 3 4 6 8))) ;; => '((nil 1 1 3) (t 2 2 2 4 6 8))

(defun d-elem-index (elem list))
(defun d-elem-indices (elem list))
(defun d-find-index (pred list))
(defun d-find-last-index (pred list))
(defun d-find-indices (pred list))
(defun d-grade-up (comparator list))
(defun d-grade-down (comparator list))

(defun d-union (list1 list2)
  (let ((res (list)))
    (dolist (el list1) (unless (contain res el) (push res el)) )
    (dolist (el list2) (unless (contain res el) (push res el)) )
    res))

(defun d-difference (list list2)
  (let ((res (list)))
    (dolist (el list1) (unless (contain list2 el) (push res el)))
    res))

(defun d-intersection (list1 list2)
  (let ((res (list)))
    (dolist (el list1) (when (contain list2 el) (push res el)))
    res))

(defun d-powerset (lis)
  (when (<= (length lis) 1) (return (list lis (list))))
  (let ((res (list ))
        (h (head lis)))    
    (dolist (el (d-powerset (tail lis)))
      (push res (d-concat `(,h) el))
      (push res el))
    res))

(defun d-permutations (list))

(defun d-distinct (lis)
  (let ((res (lis)))
    (dolist (el lis) (unless (contain res el) (push res el)))
    (length res)))

(defun d-rotate (n list))

(defun d-repeat (n x)
  (let ((res (list)))
    (dotimes (i n) (push res x))
    res))

(defun d-cons* (&rest args))
(defun d-snoc (list elem &rest elements))
(defun d-interpose (sep list))
(defun d-interleave (&rest lists))
(defun d-zip-with (fn list1 list2))
(defun d-zip (&rest lists))
(defun d-zip-lists (&rest lists))
(defun d-zip-fill (fill-value &rest lists))
(defun d-unzip (lists))
(defun d-cycle (list))
(defun d-pad (fill-value &rest lists))
(defun d-table (fn &rest lists))
(defun d-table-flat (fn &rest lists))
(defun d-first (pred list))
(defun d-some (pred list))
(defun d-last (pred list))
(defun d-first-item (list))
(defun d-second-item (arg1))
(defun d-third-item (arg1))
(defun d-fourth-item (list))
(defun d-fifth-item (list))
(defun d-last-item (list))
(defun d-butlast (list))
(defun d-sort (comparator list))
(defun d-list (&rest args))
(defun d-fix (fn list))

(defun d-tree-seq (branch children tree))
(defun d-tree-map (fn tree))
(defun d-tree-map-nodes (pred fun tree))
(defun d-tree-reduce (fn tree))
(defun d-tree-reduce-from (fn init-value tree))
(defun d-tree-mapreduce (fn folder tree))
(defun d-tree-mapreduce-from (fn folder init-value tree))
(defun d-clone (list))

(defun d-each (list fn))
(defun d-each-while (list pred fn))
(defun d-each-indexed (list fn))
(defun d-each-r (list fn))
(defun d-each-r-while (list pred fn))
(defun d-dotimes (num fn))
(defun d-doto (eval-initial-value &rest forms))

;; (dump (d-map-when (lambda (x) (== (mod x 2) 0)) (lambda (x) (* x 2)) '(1 2 3 4 5 6 7 8)))
;; (dump (d-map-first even? square '(1 2 3 4 5 6 7 8)))
;; (dump (d-map-last even? square '(1 2 3 4 5 6 7 8)))
;; (dump (d-map-indexed (lambda (index item) (- item index)) '(1 2 3 4))) ;; => '(1 1 1 1)
;; (dump (d-annotate square '(1 2 3))) ;; => '((2 . 1) (3 . 2) (4 . 3))
;; (dump (d-splice 'even? (lambda (x) (list x x)) '(1 2 3 4))) ;; => '(1 2 2 3 4 4)
;; (dump (d-splice-list 'even? '(a b c) '(1 2 3 4))) ;; => '(1 a b c 2)
;; (dump (d-mapcat (lambda (item) (list 0 item)) '(1 2 3))) ;; => '(0 1 0 2 0 3)
;; (dump (d-copy '(1 2 3))) ;; => '(1 2 3)
;; (dump (d-filter (lambda (num) (== 0 (mod num 2))) '(1 2 3 4))) ;; => '(2 4)
;; (dump (d-remove (lambda (num) (== 0 (mod num 2))) '(1 2 3 4))) ;; => '(2 4)
;; (dump (d-remove-first 'even? '(1 3 5 4 7 8 10))) ;; => '(1 3 5 7 8 10)
;; (dump (d-remove-last 'even? '(1 3 5 4 7 8 10))) ;; => '(1 3 5 7 8 10)
;; (dump (d-non-nil '(1 nil 2 nil nil 3 4 nil 5 nil))) ;; => '(1 2 3 4 5)
;; (dump (d-slice '(1 2 3 4 5) 1)) ;; => '(2 3 4 5)
;; (dump (d-slice '(1 2 3 4 5) 1 -2)) ;; => '(1 2 3)
;; (dump (d-slice '(1 2 3 4 5 6 7 8 9) 1 -1 2)) ;; => '(2 4 6 8)
;; (dump (d-take 3 '(1 2 3 4 5))) ;; => '(1 2 3)
;; (dump (d-take 17 '(1 2 3 4 5))) ;; => '(1 2 3 4 5)
;; (dump (d-take-last 3 '(1 2 3 4 5))) ;; => '(3 4 5)
;; (dump (d-take-last 17 '(1 2 3 4 5))) ;; => '(1 2 3 4 5)
;; (dump (d-take-last 1 '(1 2 3 4 5))) ;; => '(5)
;; (dump (d-drop 3 '(1 2 3 4 5))) ;; => '(4 5)
;; (dump (d-drop 17 '(1 2 3 4 5))) ;; => '()
;; (dump (d-drop-last 3 '(1 2 3 4 5))) ;; => '(1 2)
;; (dump (d-drop-last 17 '(1 2 3 4 5))) ;; => '()
;; (dump (d-take-while 'even? '(1 2 3 4))) ;; => '()
;; (dump (d-take-while 'even? '(2 4 5 6))) ;; => '(2 4)
;; (dump (d-drop-while 'even? '(1 2 3 4))) ;; => '(1 2 3 4)
;; (dump (d-drop-while 'even? '(2 4 5 6))) ;; => '(5 6)
;; (dump (d-select-by-indices '(4 10 2 3 6) '("v" "e" "l" "o" "c" "i" "r" "a" "p" "t" "o" "r"))) ;; => '("c" "o" "l" "o" "r")
;; (dump (d-select-by-indices '(2 1 0) '("a" "b" "c"))) ;; => '("c" "b" "a")
;; (dump (d-select-by-indices '(0 1 2 0 1 3 3 1) '("f" "a" "r" "l"))) ;; => '("f" "a" "r" "f" "a" "l" "l" "a")
;; (dump (d-select-columns '(0 2) '((1 2 3) (a b c) (:a :b :c)))) ;; => '((1 3) (a c) (:a :c))
;; (dump (d-select-columns '(1) '((1 2 3) (a b c) (:a :b :c)))) ;; => '((2) (b) (:b))
;; (dump (d-select-columns nil '((1 2 3) (a b c) (:a :b :c)))) ;; => '(nil nil nil)
;; (dump (d-select-column 1 '((1 2 3) (a b c) (:a :b :c)))) ;; => '(2 b :b)
;; (dump (d-keep (lambda (num) (when (> num 3) (* 10 num))) '(1 2 3 4 5 6))) ;; => '(40 50 60)
;; (dump (d-concat '(1))) ;; => '(1)
;; (dump (d-concat '(1) '(2))) ;; => '(1 2)
;; (dump (d-concat '(1) '(2 3) '(4))) ;; => '(1 2 3 4)
;; (dump (d-flatten '((1)))) ;; => '(1)
;; (dump (d-flatten '((1 (2 3) (((4 (5)))))))) ;; => '(1 2 3 4 5)
;; (dump (d-flatten '(1 2 (3 4)))) ;; => '(1 2 (3 . 4))
;; (dump (d-replace 1 "1" '(1 2 3 4 3 2 1))) ;; => '("1" 2 3 4 3 2 "1")
;; (dump (d-replace "foo" "bar" '("a" "nice" "foo" "sentence" "about" "foo"))) ;; => '("a" "nice" "bar" "sentence" "about" "bar")
;; (dump (d-replace 1 2 nil)) ;; => nil
;; (dump (d-replace-first 1 "1" '(1 2 3 4 3 2 1))) ;; => '("1" 2 3 4 3 2 1)
;; (dump (d-replace-first "foo" "bar" '("a" "nice" "foo" "sentence" "about" "foo"))) ;; => '("a" "nice" "bar" "sentence" "about" "foo")
;; (dump (d-replace-first 1 2 nil)) ;; => nil
;; (dump (d-replace-last 1 "1" '(1 2 3 4 3 2 1))) ;; => '(1 2 3 4 3 2 "1")
;; (dump (d-replace-last "foo" "bar" '("a" "nice" "foo" "sentence" "about" "foo"))) ;; => '("a" "nice" "foo" "sentence" "about" "bar")
;; (dump (d-replace-last 1 2 nil)) ;; => nil
;; (dump (d-insert-at 1 'x '(a b c))) ;; => '(a x b c)
;; (dump (d-insert-at 12 'x '(a b c))) ;; => '(a b c x)
;; (dump (d-replace-at 0 9 '(0 1 2 3 4 5))) ;; => '(9 1 2 3 4 5)
;; (dump (d-replace-at 1 9 '(0 1 2 3 4 5))) ;; => '(0 9 2 3 4 5)
;; (dump (d-replace-at 4 9 '(0 1 2 3 4 5))) ;; => '(0 1 2 3 9 5)
;; (dump (d-update-at 0 (lambda (x) (+ x 9)) '(0 1 2 3 4 5))) ;; => '(9 1 2 3 4 5)
;; (dump (d-update-at 1 (lambda (x) (+ x 8)) '(0 1 2 3 4 5))) ;; => '(0 9 2 3 4 5)
;; (dump (d-remove-at 0 '("0" "1" "2" "3" "4" "5"))) ;; => '("1" "2" "3" "4" "5")
;; (dump (d-remove-at 1 '("0" "1" "2" "3" "4" "5"))) ;; => '("0" "2" "3" "4" "5")
;; (dump (d-remove-at 2 '("0" "1" "2" "3" "4" "5"))) ;; => '("0" "1" "3" "4" "5")
;; (dump (d-remove-at-indices '(0) '("0" "1" "2" "3" "4" "5"))) ;; => '("1" "2" "3" "4" "5")
;; (dump (d-remove-at-indices '(0 2 4) '("0" "1" "2" "3" "4" "5"))) ;; => '("1" "3" "5")
;; (dump (d-remove-at-indices '(0 5) '("0" "1" "2" "3" "4" "5"))) ;; => '("1" "2" "3" "4")
;; (dump (d-iterate (lambda (x) (+ x x)) 2 5)) ;; => '(2 4 8 16 32)
;; (dump (d-unfold (lambda (x) (unless (== x 0) (list x (- x 1)))) 10)) ;; => '(10 9 8 7 6 5 4 3 2 1)
;; (dump (d-map (lambda (x) (* x 2))'(1 2 3 4 5)))
;; (dump (d-reduce-from '- 10 '(1 2 3))) ;; => 4
;; (dump (d-reduce-from '- 50 '(1 2 3))) ;; => 4
;; (dump (d-reduce-from '+ 0 '(1 2 3))) ;; => 4
;; (dump (d-reduce-r-from '- 10 '(1 2 3))) ;; => -8
;; (dump (d-reduce '- '(1 2 3 4))) ;; => -8
;; (dump (d-reduce 'list '(1 2 3 4))) ;; => '(((1 2) 3) 4)
;; (dump (d-reduce-r '- '(1 2 3 4))) ;; => -2
;; (dump (d-reductions-from 'max 0 '(2 1 4 3))) ;; => '(0 2 2 4 4)
;; (dump (d-reductions-from '* 1 '(1 2 3 4))) ;; => '(1 1 2 6 24)
;; (dump (d-reductions-r-from 'max 0 '(2 1 4 3))) ;; => '(4 4 4 3 0)
;; (dump (d-reductions-r-from '* 1 '(1 2 3 4))) ;; => '(24 24 12 4 1)
;; (dump (d-reductions '+ '(1 2 3 4))) ;; => '(1 3 6 10)
;; (dump (d-reductions '* '(1 2 3 4))) ;; => '(1 2 6 24)
;; (dump (d-reductions-r '+ '(1 2 3 4))) ;; => '(10 9 7 4)
;; (dump (d-reductions-r '* '(1 2 3 4))) ;; => '(24 24 12 4)
;; (dump (d-count 'even? '(1 2 3 4 5))) ;; => 2
;; (dump (d-sum '())) ;; => 0
;; (dump (d-sum '(1))) ;; => 1
;; (dump (d-sum '(1 2 3 4))) ;; => 10
;; (dump (d-running-sum '(1 2 3 4))) ;; => '(1 3 6 10)
;; (dump (d-running-sum '(1))) ;; => '(1)
;; (dump (d-running-sum '())) ;; Error
;; (dump (d-product '())) ;; => 1
;; (dump (d-product '(1))) ;; => 1
;; (dump (d-product '(1 2 3 4))) ;; => 24
;; (dump (d-running-product '(1 2 3 4))) ;; => '(1 2 6 24)
;; (dump (d-running-product '(1))) ;; => '(1)
;; (dump (d-running-product '())) ;; Error
;; (dump (d-inits '(1 2 3 4))) ;; => '(nil (1) (1 2) (1 2 3) (1 2 3 4))
;; (dump (d-inits nil)) ;; => '(nil)
;; (dump (d-inits '(1))) ;; => '(nil (1))
;; (dump (d-tails '(1 2 3 4))) ;; => '((1 2 3 4) (2 3 4) (3 4) (4) nil)
;; (dump (d-tails nil)) ;; => '(nil)
;; (dump (d-tails '(1))) ;; => '((1) nil)
;; (dump (d-common-prefix '(1))) ;; => '(1)
;; (dump (d-common-prefix '(1 2) '(3 4) '(1 2))) ;; => nil
;; (dump (d-common-prefix '(1 2) '(1 2 3) '(1 2 3 4))) ;; => '(1 2)
;; (dump (d-common-suffix '(1))) ;; => '(1)
;; (dump (d-common-suffix '(1 2) '(3 4) '(1 2))) ;; => nil
;; (dump (d-common-suffix '(1 2 3 4) '(2 3 4) '(3 4))) ;; => '(3 4)
;; (dump (d-min '(0))) ;; => 0
;; (dump (d-min '(3 2 1))) ;; => 1
;; (dump (d-min '(1 2 3))) ;; => 1
;; (dump (d-min-by '> '(4 3 6 1))) ;; => 1
;; (dump (d-max '(0))) ;; => 0
;; (dump (d-max '(3 2 1))) ;; => 3
;; (dump (d-max '(1 2 3))) ;; => 3
;; (dump (d-max-by '> '(4 3 6 1))) ;; => 6
;; (dump (d-any? even? '(1 2 3))) ;; => t
;; (dump (d-any? even? '(1 3 5))) ;; => nil
;; (dump (d-all? even? '(1 2 3))) ;; => nil
;; (dump (d-all? even? '(2 4 6))) ;; => t
;; (dump (d-none? 'even? '(1 2 3))) ;; => nil
;; (dump (d-none? 'even? '(1 3 5))) ;; => t
;; (dump (d-only-some? 'even? '(1 2 3))) ;; => t
;; (dump (d-only-some? 'even? '(1 3 5))) ;; => nil
;; (dump (d-only-some? 'even? '(2 4 6))) ;; => nil
;; (dump (d-contains? '(1 2 3) 1)) ;; => t
;; (dump (d-contains? '(1 2 3) 2)) ;; => t
;; (dump (d-contains? '(1 2 3) 4)) ;; => nil
;; (dump (d-same-items? '(1 2 3) '(1 2 3))) ;; => t
;; (dump (d-same-items? '(1 2 3) '(3 2 1))) ;; => t
;; (dump (d-same-items? '(1 2 3) '(1 2 3 4))) ;; => nil
;; (dump (d-is-prefix? '(1 2 3) '(1 2 3 4 5))) ;; => t
;; (dump (d-is-prefix? '(1 2 3 4 5) '(1 2 3))) ;; => nil
;; (dump (d-is-prefix? '(1 3) '(1 2 3 4 5))) ;; => nil
;; (dump (d-is-infix? '(1 2 3) '(1 2 3 4 5))) ;; => t
;; (dump (d-is-infix? '(2 3 4) '(1 2 3 4 5))) ;; => t
;; (dump (d-is-infix? '(3 4 5) '(1 2 3 4 5))) ;; => t
;; (dump (d-powerset '(x y z))) ;; => '((x y z) (x y) (x z) (x) (y z) (y) (z) nil)
