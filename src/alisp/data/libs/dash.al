(defvar --doc-- "Dash helps you work with lists")

(defun d-map (fn list)
  (mapcar fn list))

(defun d-map-when (pred rep l)
  (let ((res (list)))
    (dolist (el l)
      (when (pred el)
        (push res (rep el))))
    res))

(defun d-map-first (pred rep l)
  (let ((res (list))
        (found nil))
    (dolist (el l)
      (if (and (pred el) (not found))
          (progn
            (push res (rep el))
            (setq found 't)))
      (push res el))
    res))

(defun d-map-last (pred rep l)
  (let ((res (list))
        (found nil))
    (dolist (el (reverse l))
      (if (and (pred el) (not found))
          (progn
            (push res (rep el))
            (setq found 't))
        (push res el)))
    (reverse res)))

(defun d-map-indexed (fn lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (push res (fn i (nth lis i))))
    res))

(defun d-annotate (fn lis)
  (let ((res (list)))
    (dolist (el lis)
      (push res (list (fn el) el)))
    res))

(defun d-splice (pred fun lis)
  (let ((res (list)))
    (dolist (el lis)
      (if (pred el)
          (dolist (new-el (fun el))
            (push res new-el))
        (push res el)))
    res))

(defun d-splice-list (pred new-list lis)
  (let ((res (list)))
    (dolist (el lis)
      (if (pred el)
          (dolist (new-el new-list)
            (push res new-el))
        (push res el)))
    res))

(defun d-mapcat (fn lis)
  (let ((res (list)))
    (dolist (el lis)
      (dolist (new-el (fn el))
        (push res new-el)))
    res))

(defun d-copy (arg)
  (let ((res (list)))
    (dolist (el arg)
      (push res el))
    res))

(defun d-filter (pred lis)
  (filter pred lis))

(defun d-remove (pred lis)
  (filter (lambda (x) (not (pred x))) lis))

(defun d-remove-first (pred lis)
  (let ((res (list))
        (found nil))
    (dolist (el lis)
      (if (and (pred el) (not found))
          (setq found 't)
        (push res el)))
    res))

(defun d-remove-last (pred lis)
  (let ((res (list))
        (found nil))
    (dolist (el (reverse lis))
      (if (and (pred el) (not found))
          (setq found 't)
        (push res el)))
    (reverse res)))

(defun d-remove-item (item list)
  (delete list item))

(defun d-non-nil (list)
  (filter (lambda (x) (not ( equal x nil))) list))

(defun d-slice (lis from &optional to step)
  (when (equal from to) (return (list)))
  (let ((res (list)))
    (dolist (i (range from (if to (if (> 0 to) (+ (length lis) to 1) to) (length lis)) (if step step 1)))
      (push res (nth lis i)))
    res))

(defun d-take (n lis)
  (let ((res (list)))
    (dolist (i (range 0 (min (length lis) n)))
      (push res (nth lis i)))
    res))

(defun d-take-last (n lis)
  (let ((res (list)))
    (dolist (i (range (max 0 (- (length lis) n)) (length lis)))
      (push res (nth lis i)))
    res))

(defun d-drop (n lis)
  (let ((res (list)))
    (dolist (i (range n (length lis)))
      (push res (nth lis i)))
    res))

(defun d-drop-last (n lis)
  (let ((res (list)))
    (dolist (i (range 0 (- (length lis) n)))
      (push res (nth lis i)))
    res))

(defun d-take-while (pred lis)
  (let ((res (list)))
    (dolist (el lis)
      (if (pred el)
          (push res el)
        (return res)))
    res))

(defun d-drop-while (pred lis)
  (let ((res (list))
        (found nil))
    (dolist (el lis)
      (unless (and (pred el) (not found))
        (push res el)
        (setq found 't)))
    res))

(defun d-select-by-indices (indices lis)
  (let ((res (list)))
    (dolist (i indices)
      (push res (nth lis i)))
    res))

(defun d-select-columns (columns table)
  (let ((res (list)))
    (dolist (row table)
      (let ((new-row (list)))
        (when (not columns)  (push res 'nil) (continue))
        (dolist (i columns)
          (push new-row (nth row i)))
        (push res new-row)))
    res))

(defun d-select-column (column table)
  (let ((res (list)))
    (dolist (row table)
      (when (equal column nil) (push res 'nil) (continue))
      (push res (nth row column)))
    res))

(defun d-keep (fn lis)
  (let ((res (list))
        el-res)
    (dolist (el lis)
      (setq el-res (fn el))
      (unless (equal el-res nil) (push res el-res)))
    res))

(defun d-concat (&rest lists)
  (let ((res (list)))
    (dolist (lis lists)
      (dolist (el lis)
        (push res el)))
    res))

(defun d-flatten (l)
  (let ((res (list)))
    (dolist (el l)
      (if (plist el)
          (dolist (new-el (d-flatten el)) (push res new-el))
        (push res el)))
    res))

(defun d-replace (old new lis)
  (when (equal lis nil) (return nil))
  (let ((res (list)))
    (dolist (el lis)
      (if (equal el old)
          (push res new)
        (push res el)))
    res))

(defun d-replace-first (old new l)
  (when (equal l nil) (return nil))
  (let ((res (list))
        (found nil))
    (dolist (el l)
      (if (and (equal el old) (not found))
          (progn
            (push res new)
            (setq found 't))
        (push res el)))
    res))

(defun d-replace-last (old new l)
  (when (equal l nil) (return nil))
  (let ((res (list))
        (found nil))
    (dolist (el (reverse l))
      (if (and (equal el old) (not found))
          (progn
            (push res new)
            (setq found 't))
        (push res el)))
    (reverse res)))

(defun d-insert-at (n x lis)
  (let ((res (list)))
    (dolist (el lis)
      (push res el))
    (insert res (min n (length res)) x)))

(defun d-replace-at (n x lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (if (== i n)
          (push res x)
        (push res (nth lis i))))
    res))

(defun d-update-at (n func lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (if (== i n)
          (push res (func (nth lis i)))
        (push res (nth lis i))))
    res))

(defun d-remove-at (n lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (unless (== i n)
        (push res (nth lis i))))
    res))

(defun d-remove-at-indices (indices lis)
  (let ((res (list)))
    (dotimes (i (length lis))
      (unless (contains indices i)
        (push res (nth lis i))))
    res))

(defun d-reduce-from (fn initial-value lis)
  (let ((val (fn initial-value (head lis))))
    (dolist (el (tail lis))
      (setq val (fn val el)))
    val))

(defun d-reduce-r-from (fn initial-value lis)
  (let ((val (fn (last lis) initial-value)))
    (dolist (el (reverse (init lis)))
      (setq val (fn el val)))
    val))

(defun d-reduce (fn lis)
  (let ((val (fn (nth lis 0) (nth lis 1))))
    (dolist (i (range 2 (length lis)))
      (setq val (fn val (nth lis i))))
    val))

(defun d-reduce-r (fn lis)
  (let* ((len (length lis))
         (val (fn (nth lis (- len 1)) (nth lis (- len 2)) )))
    (dolist (i (range 3 (+ len 1)))
      (setq val (fn val (nth lis (- len i))  )))
    val))

(defun d-reductions-from (fn init lis)
  (let ((res (list init (fn init (head lis)))))
    (dolist (i (range 1 (length lis)))
      (push res (fn (last res) (nth lis i))))
    res))

(defun d-reductions-r-from (fn initial-value lis)
  (let ((res (list initial-value (fn (last lis) initial-value))))
    (dolist (el (reverse (init lis)))
      (push res (fn el (last res))))
    (reverse res)))

(defun d-reductions (fn lis)
  (let ((res (list (head lis) (fn (nth lis 0) (nth lis 1)))))
    (dolist (i (range 2 (length lis)))
      (push res (fn (last res) (nth lis i))))
    res))

(defun d-reductions-r (fn lis)
  (let* ((len (length lis))
         (res (list (fn (nth lis (- len 1)) (nth lis (- len 2)) ))))
    (dolist (i (range 3 (+ len 1)))
      (push res (fn (last res) (nth lis (- len i))  )))
    (shove res (last lis))
    (reverse res)))

(defun d-count (pred lis)
  (let ((cnt 0))
    (dolist (el lis)
      (when (pred el) (setq cnt (+ cnt 1))))
    cnt))

(defun d-sum (lis)
  (when (equal lis nil) (return 0))
  (let ((sm 0))
    (dolist (el lis)
      (setq sm (+ sm el)))
    sm))

(defun d-running-sum (lis)
  (when (equal lis nil) (return '(0)))
  (let ((sm (list 0)))
    (dolist (el lis)
      (push sm (+ (last sm) el)))
    (tail sm)))

(defun d-product (lis)
  (when (equal lis nil) (return 1))
  (let ((sm 1))
    (dolist (el lis)
      (setq sm (* sm el)))
    sm))

(defun d-running-product (lis)
  (when (equal lis nil) (return '(1)))
  (let ((sm (list 1)))
    (dolist (el lis)
      (push sm (* (last sm) el)))
    (tail sm)))

(defun d-inits (lis)
  (when (equal nil lis) (return '(nil)))
  (let ((res (list nil)))
    (dotimes (i (length lis))
      (let ((in (list)))
        (dotimes (j (+ 1 i)) (push in (nth lis j)) )
        (push res in)))
    res))

(defun d-tails (lis)
  (when (equal nil lis) (return '(nil)))
  (let ((res (list nil))
        (rev (reverse lis)))
    (dotimes (i (length lis))
      (let ((in (list)))
        (dotimes (j (+ 1 i)) (push in (nth rev j)) )
        (push res (reverse in))))
    (reverse res)))

(defun d-common-prefix (&rest l)
  (when (== (length l) 1) (return (nth l 0)))
  (let ((res (list))
        (len (d-reduce min (mapcar length l))))
    (dotimes (i len)
      (let ((el (nth (nth l 0) i)))
        (dolist (lis l)
          (if (not (equal (nth lis i) el)) (return res)))
        (push res el)))
    res))

(defun d-common-suffix (&rest lists)
  (reverse (apply 'd-common-prefix (mapcar quote (mapcar reverse lists)))))

(defun d-min (lis)
  (apply min lis))

(defun d-min-by (comparator lis)
  (d-reduce (lambda (acc x) (if (comparator x acc) acc x)) lis))

(defun d-max (lis)
  (apply max lis))

(defun d-max-by (comparator lis)
  (d-reduce (lambda (acc x) (if (comparator x acc) x acc)) lis))

(defun d-iterate (fun init n)
  (let ((res (list))
        (last-el init))
    (dotimes (i n)
      (push res last-el)
      (setq last-el (fun last-el)))
    res))

(defun d-unfold (fun seed)
  (let ((res (list))
        (last-el (fun seed)))
    (while (not (equal last-el nil))
      (push res (nth last-el 0))
      (setq last-el (fun (nth last-el 1))))
    res))

(defun d-any? (pred lis)
  (any pred lis))

(defun d-all? (pred lis)
  (all pred lis))

(defun d-none? (pred list)
  (dolist (el list)
    (when (pred el)
      (return nil)))
  t)

(defun d-only-some? (pred lis)
  (let ((matched nil)
        (unmatched t)
        res)
    (dolist (el lis)
      (setq res (pred el))
      (setq matched (or res matched))
      (setq unmatched (and res unmatched)))
    (when (and matched (not unmatched)) (return t))))

(defun d-contains? (list element)
  (contains list element))

(defun d-same-items? (list1 list2)
  (when (!= (length list1) (length list2)) (return nil))
  (dolist (el list1)
    (unless (contains list2 el) (return nil)))
  t)

(defun d-is-prefix? (prefix lis)
  (when (> (length prefix) (length lis)) (return nil))
  (let ((i 0))
    (dolist (p prefix)
      (when (not (equal p (nth lis i))) (return nil))
      (1+ i))
    t))

(defun d-is-suffix? (suffix list)
  (d-is-prefix? (reverse suffix) (reverse list)))

(defun d-is-infix? (infix lis)
  (let ((done nil)
        (ls (d-copy lis)))
    (while (and (not done) ls)
      (setq done (d-is-prefix? infix ls))
      (setq ls (tail ls)))
    done))

(defun d-split-at (n lis)
  (let ((res1 (list))
        (res2 (list)))
    (dotimes (i (min n (length lis))) (push res1 (nth lis i)))
    (dolist (i (range n (length lis))) (push res2 (nth lis i)))
    (list res1 res2)))

(defun d-split-with (pred lis)
  (let ((res1 (list))
        (res2 (list))
        (len (length lis))
        (i 0))
    (while (and (pred (nth lis i)) (< i len))
      (push res1 (nth lis i))
      (1+ i))
    (dolist (j (range i len)) (push res2 (nth lis j)))

    (list res1 res2)))

(defun d-split-on (item lis)
  (let ((res (list))
        (temp (list)))
    (dolist (el lis)
      (if (equal el item)
          (progn
            (push res (d-copy temp))
            (clear temp))
        (push temp el)))
    (push res (d-copy temp))
    res))

(defun d-split-when (fn lis)
  (let ((res (list))
        (temp (list)))
    (dolist (el lis)
      (if (fn el)
          (progn
            (unless (empty temp)
              (push res (d-copy temp))
              (clear temp)))
        (push temp el)))
    (unless (empty temp) (push res (d-copy temp)))
    res))

(defun d-separate (pred lis)
  (let ((res1 (list))
        (res2 (list)))
    (dolist (el lis)
      (if (pred el)
          (push res1 el)
        ( push res2 el)))
    (list res1 res2)))

(defun d-partition (n lis)
  (let ((res (list))
        (temp (list))
        (i 0))
    (dolist (el lis)
      (if (< i n)
          (progn
            (push temp el)
            (1+ i))
        (push res (d-copy temp))
        (clear temp)
        (push temp el)
        (setq i 1)))
    res))

(defun d-partition-all (n lis)
  (let ((res (list))
        (temp (list))
        (i 0))
    (dolist (el lis)
      (if (< i n)
          (progn
            (push temp el)
            (1+ i))
        (push res (d-copy temp))
        (clear temp)
        (push temp el)
        (setq i 1)))
    (push res (d-copy temp))
    res))

(defun d--partition-all-in-steps-reversed (n step lis)
  (let ((res (list)))
    (while lis
      (push res (d-take n lis))
      (setq lis (d-drop step lis)))
    res))

(defun d-partition-in-steps (n step lis)
  (filter (lambda (l) (== (length l) n))(d--partition-all-in-steps-reversed n step lis)))

(defun d-partition-all-in-steps (n step lis)
  (d--partition-all-in-steps-reversed n step lis))

(defun d-partition-by (fn lis)
  (let ((res (list))
        (temp (list))
        prev-val val)
    (dolist (el lis)
      (setq val (fn el))
      (if (equal val prev-val)
          (push temp el)
        (push res (d-copy temp))
        (clear temp)
        (push temp el))
      (setq prev-val val))
    (unless (empty temp) (push res (d-copy temp)))
    res))

(defun d-partition-by-header (fn lis)
  (let ((res (list))
        (temp (list))
        (header (fn (head lis))))
    (dolist (el lis)
      (if (not (and (equal header (fn el))
                    (!= (length temp) 1)))
          (push temp el)
        (unless (empty temp) (push res (d-copy temp)))
        (clear temp)
        (push temp el)))
    (unless (empty temp) (push res (d-copy temp)))
    res))

(defun d-group-by (fn lis)
  (let ((res (list))
        (group-vals (list))
        (i 0)
        val)
    (dolist (el lis)
      (setq val (fn el))
      (if (contains group-vals val)
          (progn
            (push (nth res (nth group-vals (inc (find group-vals val)))) el)
            )
        (push group-vals val)
        (push group-vals i)
        (1+ i)
        (push res (list val el))))
    res))

(defun d-elem-index (elem list)
  (find list elem))

(defun d-elem-indices (elem lis)
  (let ((res (list)))
    (dolist (i (range 0 (length lis)))
      (when (equal (nth lis i) elem)
        (push res i)))
    res))

(defun d-find-index (pred lis)
  (dolist (i (range 0 (length lis)))
    (when (pred (nth lis i))
      (return i))))

(defun d-find-indices (pred lis)
  (let ((res (list)))
    (dolist (i (range 0 (length lis)))
      (when (pred (nth lis i))
        (push res i)))
    res))

(defun d-find-last-index (pred lis)
  (last (d-find-indices pred lis)))

(defun d-union (list1 list2)
  (let ((res (list)))
    (dolist (el list1) (unless (contain res el) (push res el)) )
    (dolist (el list2) (unless (contain res el) (push res el)) )
    res))

(defun d-difference (list list2)
  (let ((res (list)))
    (dolist (el list1) (unless (contain list2 el) (push res el)))
    res))

(defun d-intersection (list1 list2)
  (let ((res (list)))
    (dolist (el list1) (when (contain list2 el) (push res el)))
    res))

(defun d-powerset (lis)
  (when (<= (length lis) 1) (return (list lis (list))))
  (let ((res (list ))
        (h (head lis)))
    (dolist (el (d-powerset (tail lis)))
      (push res (d-concat `(,h) el))
      (push res el))
    res))

(defun d-permutations (lis)
  (when (<= (length lis) 1) (return (list lis )))
  (let ((res (list ))
        (h (head lis)))
    (dolist (per (d-permutations (tail lis)))
      (dolist (i (range 0 (length lis)))
        (push res (d-concat (d-slice per 0 i) (list h) (d-slice per i)))))
    res))

(defun d-distinct (lis)
  (let ((res (lis)))
    (dolist (el lis) (unless (contain res el) (push res el)))
    (length res)))

(defun d-rotate (n list))

(defun d-repeat (n x)
  (let ((res (list)))
    (dotimes (i n) (push res x))
    res))

(defun d-first (pred lis)
  (dolist (el lis)
    (when (pred el) (return el)))
  nil)

(defun d-some (pred list)
  (dolist (el lis)
    (when (pred el) (return t)))
  nil)

(defun d-last (pred list)
  (dolist (el (reverse lis))
    (when (pred el) (return el)))
  nil
  )

(defun d-first-item (list)
  (head list))

(defun d-second-item (arg1)
  (when (> (length arg1) 1) (return (nth arg1 1)))
  nil)

(defun d-third-item (arg1)
  (when (> (length arg1) 2) (return (nth arg1 2)))
  nil)

(defun d-fourth-item (arg1)
  (when (> (length arg1) 3) (return (nth arg1 3)))
  nil)

(defun d-fifth-item (arg1)
  (when (> (length arg1) 4) (return (nth arg1 4)))
  nil)

(defun d-last-item (list)
  (last list))

(defun d-butlast (list)
  (init list))

(defun d-list (&rest args)
  args)

(defun d-each (list fn)
  (dolist (el list) (fn el)))

(defun d-each-while (list pred fn)
  (dolist (el list)
    (when (pred el) (fn el))))

(defun d-each-indexed (list fn)
  (dolist (i (ranger 0 (length list)))
    (fn i (nth list i))))

(defun d-each-r (list fn)
  (dolist (el (reverse list)) (fn el)))

(defun d-each-r-while (list pred fn)
  (dolist (el (reverse list))
    (when (pred el) (fn el))))

(defun d-dotimes (num fn)
  (dotimes (i num) (fn i)))
